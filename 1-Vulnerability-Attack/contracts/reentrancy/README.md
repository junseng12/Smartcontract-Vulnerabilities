# 🛡️ Reentrancy Attack 실습 리포트

이 리포트는 재진입(Reentrancy) 공격의 개념 이해부터, 실제 공격 시도, 그리고 방어까지의 전체 흐름을 실습한 결과를 담고 있습니다.

---

## 🔧 프로젝트 구조

```
/reentrancy/
├── Vulnerable.sol         // 취약한 스마트 컨트랙트
├── AttackReentrancy.sol   // 재진입 공격용 컨트랙트
├── Secure.sol             // 방어 로직이 적용된 컨트랙트
├── AttackSecure.sol       // 방어 대상에 대해 공격을 시도하는 컨트랙트
├── attack.js              // 취약 컨트랙트 대상 공격 스크립트
├── attack-secure.js       // 방어 컨트랙트 대상 공격 스크립트
└── README.md              // 실습 정리 문서
```

---

## 🧠 실습 목표

- 재진입 공격의 구조를 명확히 이해한다
- `call`의 특성과 취약점을 실습으로 확인한다
- 방어 전략(`checks-effects-interactions`)을 코드로 구현한다
- 공격과 방어 결과를 비교 분석한다

---

## 1️⃣ Reentrancy 공격 시나리오

- 공격자는 `donate()`로 이더를 맡긴 뒤
- `withdraw()` 호출 시 `call`을 통해 이더를 받으며 `receive()`로 재진입
- 상태(`balances`)가 아직 감소하지 않았기 때문에, 반복 출금 가능 → 이더 탈취

📄 관련 파일:

- `Vulnerable.sol`
- `AttackReentrancy.sol`
- `attack.js`

### ✅ 공격 성공 조건:

- 상태 업데이트보다 `call()`이 먼저 실행됨
- `receive()` 함수에서 `withdraw()`를 반복 호출할 수 있음

---

## ❗ call() 함수로 인해 실습이 어려웠던 이유

재진입 공격 실습 과정에서 가장 큰 걸림돌이 되었던 것은 바로 Solidity의 저수준 함수인 `call()`이었습니다.

```solidity
(bool success, ) = msg.sender.call{value: amount}("");
require(success, "Transfer failed");
```

### 🚨 주요 오류 메시지:

```
❌ Attack failed: Transfer failed
```

### 🔍 그 원인을 구체적으로 분석하면:

| 원인              | 설명                                                                                        |
| ----------------- | ------------------------------------------------------------------------------------------- |
| 💥 재진입 루프    | 공격 컨트랙트의 `receive()`에서 다시 `withdraw()`를 호출하면 무한 재진입 루프 가능성이 있음 |
| ⛽ 가스 초과      | Hardhat EVM에서 재귀적으로 `withdraw()`를 호출하면 **가스가 부족해 call이 실패**할 수 있음  |
| 🌀 스택 깊이 초과 | 재진입 횟수가 많아질수록 **stack depth**가 초과되어 `call` 실패 가능성 증가                 |
| ⚙️ 환경 차이      | 실제 메인넷과 달리 Hardhat 로컬 네트워크는 호출 제한이 상대적으로 엄격하게 적용됨           |

### ⚠️ 실습 중 마주한 문제 상황

- 재진입 횟수 제한 (`reentryCount < 5`)을 두어도 여전히 `call` 실패
- `gas`를 제한하거나 명시해도 Hardhat에서 `call` 실패를 완전히 피할 수 없음
- 이로 인해 실제 공격 성공 여부와 무관하게, **`Transfer failed`로 revert가 계속 발생**

### 🧠 이 경험을 통해 배운 것

- 재진입 공격의 **이론적 구조**와 **EVM 내부 동작 간의 차이**를 이해함
- `call()`은 매우 유연하지만, **환경 조건에 따라 실패할 수 있는 비결정적 함수**임
- 실습 환경에서는 너무 완벽한(?) 공격이 오히려 **실행 실패**로 이어질 수 있음
- 실제 공격 성공을 보장하려면 **정밀한 가스 설정, EVM 환경 튜닝**, 또는 **보다 간단한 반복 횟수 설계**가 필요함

---

## 2️⃣ 방어 로직 적용 (Secure.sol)

- 상태 변경을 먼저 수행하고 `call()`을 마지막에 실행
- 이로 인해 재진입 시 `require(balances[msg.sender] >= amount)`가 실패

📄 관련 파일:

- `Secure.sol`
- `AttackSecure.sol`
- `attack-secure.js`

### ✅ 방어 성공 결과 (실행 로그)

**Call() 함수** 상의 기반

```
❌ Attack failed: Transfer failed
📊 Attacker contract balance: 0.0 ETH
🏦 Secure contract balance: 5.0 ETH
```

---

## 📌 결과 요약

| 항목                   | 결과                                                 |
| ---------------------- | ---------------------------------------------------- |
| 재진입 공격 성공 여부  | ✅ 성공 (Vulnerable.sol 기준)                        |
| 방어 컨트랙트에서 공격 | ✅ 차단됨 (Secure.sol 기준)                          |
| 핵심 차이점            | 상태 변경 순서 차이 (`balances -= amount`) 먼저 수행 |

---

## 🧩 배운 점 정리

- Solidity의 `call()`은 재진입을 허용하므로 주의가 필요하다
- **Checks → Effects → Interactions** 순서가 보안 설계의 핵심이다
- 재진입 공격은 작은 코드 순서 하나로 시스템 전체를 무너뜨릴 수 있다
- 로컬 개발 환경에서의 `call` 동작은 실전 환경과 차이가 날 수 있다 (특히 gas, stack 등)

---

# [Reentrancy 실습 Failure Log]

## ✅ 시나리오 개요

- 1. `Vulnerable.sol` 스마트 컨트랙트 작성

- 2. `AttackReentrancy.sol`에서 재진입 공격 수행

- 3. Hardhat으로 테스트 및 공격 시도

---

**실습 진행: junseng12@gmail.com**

---
