# 🛠️ Reentrancy 취약점 실습 분석 보고서

## 📌 실습 목표

- `Reentrancy` 취약점의 동작 원리를 **저수준 call 흐름**에서부터 **트랜잭션 revert 복기**까지 전체 구조로 파악한다.
- Hardhat 환경에서 **디버깅 기반의 재진입 트리거 실습**을 수행하고, **공격이 수익화되지 못한 이유**를 추적한다.

---

## 🔍 실습 개요

- **공격 방식**: 취약 컨트랙트의 `withdraw()` 함수에서 `call{value: ...}("")` 호출 직후 상태 변경 전에 `receive()`를 통한 재진입 유도
- **공격 흐름**
  1. 공격 컨트랙트가 1 ETH를 기부
  2. `withdraw(1 ether)` 호출
  3. `call`을 통해 이더 전송되며 `receive()` 트리거
  4. `receive()`에서 `withdraw()` 재호출하여 재진입 발생

---

## ⚙️ 주요 실험 코드 분석

```solidity
// Vulnerable.sol
function withdraw(uint amount) external {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success, "Transfer failed");
    balances[msg.sender] -= amount;
}
```

```solidity
// AttackReentrancy.sol
receive() external payable {
    if (address(vulnerable).balance >= 1 ether) {
        vulnerable.withdraw(1 ether);
    }
}
```

---

## 📊 실험 결과 로그 요약

![alt text](image-1.png)

- 재진입은 총 **6회 발생**하였으며, 각 단계마다 `receive()` 함수가 발동됨을 확인
- **vulnerable 컨트랙트의 잔액은 6 ETH → 0 ETH → 다시 6 ETH로 복구됨**
- 공격 컨트랙트, EOA 모두 **수익은 발생하지 않음**
- **트랜잭션은 마지막 단계에서 revert 발생**하여 전체 state가 롤백되었기 떄문임

require문을 삭제하여도 여러 조건 상 취약 컨트랙트 코드의 조건을 건드리지 않는 한 revert 발생하여 롤백됨

---

## ❗ 주요 인사이트 요약

| 항목                       | 분석 결과                                                    |
| -------------------------- | ------------------------------------------------------------ |
| ✅ 재진입 트리거 여부      | 6회 재진입 성공                                              |
| ✅ 취약 컨트랙트 자산 감소 | 6 ETH → 0 ETH                                                |
| ⚠️ 트랜잭션 revert         | 마지막 call 실패로 인해 발생                                 |
| ❌ 수익 실현 여부          | 없음                                                         |
| 🧠 핵심 디버깅             | `msg.sender.call()` 이후 실패/성공 여부, receive() 로그 확인 |

---

## 💡 해킹 관점에서 얻은 직관

- **재진입이 발생했다고 해서 무조건 공격 성공이 아니다**
- **call 성공 여부 / 수신자 상태 변경 / fallback 예외 처리**가 실제 수익화에 결정적
- Hardhat에서는 `revert` 발생 시 Solidity의 `console.log()`는 출력되지 않으므로,
  JS 스크립트에서 **state 변경 추적 및 이벤트 파싱**으로 디버깅 필요
- 단순 공격 복붙이 아니라, 실제로 어떤 조건이 충족되어야 공격이 수익으로 이어지는지를 스스로 체감함

---

## ✅ 결론

> 이 실습을 통해 우리는 "재진입 취약점이 일어나는 조건"과 "공격이 실제 수익화되는 조건의 차이"를 구조적으로 탐색했다.  
> 이 과정에서 단순 코드 실행이 아닌, **상태 변화 추적 / 잔액 비교 / revert 처리 흐름 분석**이라는  
> 해킹적 탐구력을 기반으로 학습을 진행하였다.
