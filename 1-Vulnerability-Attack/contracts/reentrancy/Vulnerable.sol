// SPDX-License-Identifier: MIT
// 전제: 재진입 허용 로직이 포함되어 있는 것 (취약한 버전의 컨트랙트 가져옴)
pragma solidity ^0.8.0;

import "hardhat/console.sol";

contract Vulnerable {
    mapping(address => uint) public balances;

    function donate() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount) external {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        //call{value: X}("")	ETH를 전송하고, 동시에 함수를 호출할 수도 있는 저수준 함수
        //call{value: X}	gas 제한 없음 → 재진입 위험 존재 (❗취약점 발생 주 원인)
        //→ call은 유연하지만 위험해 → 그래서 ReentrancyGuard 같은 방어 로직이 필요해
        console.log("Balance before call: %s", address(this).balance);
        (bool success, ) = msg.sender.call{value: amount}("");
        console.log("Success status: %s", success);
        console.log("Balance after call: %s", address(this).balance);
        require(success, "Transfer failed");
        balances[msg.sender] -= amount;
    }

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }

    receive() external payable {}
}