# 🛠️ Delegatecall 실습 디버깅 분석 보고서

## 📌 디버깅 목표

- delegatecall을 통한 공격이 왜 실패한 것처럼 보였는지 분석한다.
- 실습 중 로그를 기반으로 호출자의 컨텍스트를 추적한다.

## ❗ 문제 상황 요약

- 공격을 수행했음에도 `Victim.owner` 값이 **변하지 않는 것처럼 보였다.**
- 실습 로그에 따르면 delegatecall은 정상 수행됐고, Malicious.pwn()도 호출됨
- 하지만 owner 값은 기존과 같음 → 공격 실패처럼 보임

## 🔍 원인 분석

| 항목 | 분석 |
|------|------|
| msg.sender | delegatecall에서도 **유지됨 (EOA) → 정상 작동** |
| 문제 원인 | **Victim.owner의 초기값이 이미 msg.sender와 같았음** |
| 구조 문제 | 공격자와 Victim 배포자가 **같은 주소였기 때문에 변화가 없었음**

## 🔧 해결 방법

- Victim은 deployer 계정으로 배포
- 공격자는 별도의 EOA 계정을 사용하여 delegateSet 호출
- 이로 인해 `msg.sender != Victim.owner` 조건이 충족되어, 공격 성공 결과 확인 가능

## ✅ 디버깅 로그 기반 재구성

```
Before attack owner: 0xDeployer
Malicious.pwn() called
msg.sender: 0xAttacker
After attack owner: 0xAttacker ✅
```

## 🧠 얻은 통찰

- delegatecall 구조는 매우 강력하지만, 호출 컨텍스트를 정확히 이해하지 않으면 **공격/방어 모두 착각할 수 있다.**
- 실습을 통해 `storage layout`, `msg.sender`, `delegatecall 위치`가 **모두 중요하게 상호작용한다는 사실**을 체감할 수 있었다.
- 실전에서도 Proxy/Upgradable 패턴에서 동일한 구조가 반복되며, **초기화 누락이나 잘못된 검증이 권한 탈취로 이어질 수 있다.**